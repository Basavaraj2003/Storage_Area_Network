{"ast":null,"code":"let ws = null;\nlet reconnectAttempts = 0;\nlet pingInterval = null;\nconst maxReconnectAttempts = 5;\nconst reconnectDelay = 3000;\nexport function connectWebSocket(onMessage, onError, onClose) {\n  const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n  const host = window.location.hostname;\n  const port = process.env.REACT_APP_WS_PORT || '8001';\n  const wsUrl = `${protocol}//${host}:${port}/ws`;\n  try {\n    ws = new WebSocket(wsUrl);\n    ws.onopen = () => {\n      console.log('WebSocket connected to', wsUrl);\n      reconnectAttempts = 0;\n\n      // Clear any existing ping interval\n      if (pingInterval) {\n        clearInterval(pingInterval);\n      }\n\n      // Send ping to keep connection alive\n      pingInterval = setInterval(() => {\n        if (ws && ws.readyState === WebSocket.OPEN) {\n          ws.send('ping');\n        }\n      }, 30000);\n    };\n    ws.onmessage = event => {\n      try {\n        const data = JSON.parse(event.data);\n        if (onMessage) {\n          onMessage(data);\n        }\n      } catch (error) {\n        console.error('Error parsing WebSocket message:', error);\n      }\n    };\n    ws.onerror = error => {\n      console.error('WebSocket error:', error);\n      if (onError) {\n        onError(error);\n      }\n    };\n    ws.onclose = () => {\n      console.log('WebSocket disconnected');\n      if (onClose) {\n        onClose();\n      }\n\n      // Attempt to reconnect\n      if (reconnectAttempts < maxReconnectAttempts) {\n        reconnectAttempts++;\n        console.log(`Attempting to reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`);\n        setTimeout(() => {\n          connectWebSocket(onMessage, onError, onClose);\n        }, reconnectDelay);\n      } else {\n        console.error('Max reconnection attempts reached');\n      }\n    };\n  } catch (error) {\n    console.error('Failed to create WebSocket:', error);\n    if (onError) {\n      onError(error);\n    }\n  }\n}\nexport function disconnectWebSocket() {\n  if (pingInterval) {\n    clearInterval(pingInterval);\n    pingInterval = null;\n  }\n  if (ws) {\n    ws.close();\n    ws = null;\n  }\n}\nexport function sendMessage(message) {\n  if (ws && ws.readyState === WebSocket.OPEN) {\n    ws.send(JSON.stringify(message));\n  }\n}","map":{"version":3,"names":["ws","reconnectAttempts","pingInterval","maxReconnectAttempts","reconnectDelay","connectWebSocket","onMessage","onError","onClose","protocol","window","location","host","hostname","port","process","env","REACT_APP_WS_PORT","wsUrl","WebSocket","onopen","console","log","clearInterval","setInterval","readyState","OPEN","send","onmessage","event","data","JSON","parse","error","onerror","onclose","setTimeout","disconnectWebSocket","close","sendMessage","message","stringify"],"sources":["C:/sanfinal/frontend/src/services/websocket.js"],"sourcesContent":["let ws = null;\nlet reconnectAttempts = 0;\nlet pingInterval = null;\nconst maxReconnectAttempts = 5;\nconst reconnectDelay = 3000;\n\nexport function connectWebSocket(onMessage, onError, onClose) {\n  const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n  const host = window.location.hostname;\n  const port = process.env.REACT_APP_WS_PORT || '8001';\n  const wsUrl = `${protocol}//${host}:${port}/ws`;\n\n  try {\n    ws = new WebSocket(wsUrl);\n\n    ws.onopen = () => {\n      console.log('WebSocket connected to', wsUrl);\n      reconnectAttempts = 0;\n      \n      // Clear any existing ping interval\n      if (pingInterval) {\n        clearInterval(pingInterval);\n      }\n      \n      // Send ping to keep connection alive\n      pingInterval = setInterval(() => {\n        if (ws && ws.readyState === WebSocket.OPEN) {\n          ws.send('ping');\n        }\n      }, 30000);\n    };\n\n    ws.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data);\n        if (onMessage) {\n          onMessage(data);\n        }\n      } catch (error) {\n        console.error('Error parsing WebSocket message:', error);\n      }\n    };\n\n    ws.onerror = (error) => {\n      console.error('WebSocket error:', error);\n      if (onError) {\n        onError(error);\n      }\n    };\n\n    ws.onclose = () => {\n      console.log('WebSocket disconnected');\n      if (onClose) {\n        onClose();\n      }\n      \n      // Attempt to reconnect\n      if (reconnectAttempts < maxReconnectAttempts) {\n        reconnectAttempts++;\n        console.log(`Attempting to reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`);\n        setTimeout(() => {\n          connectWebSocket(onMessage, onError, onClose);\n        }, reconnectDelay);\n      } else {\n        console.error('Max reconnection attempts reached');\n      }\n    };\n  } catch (error) {\n    console.error('Failed to create WebSocket:', error);\n    if (onError) {\n      onError(error);\n    }\n  }\n}\n\nexport function disconnectWebSocket() {\n  if (pingInterval) {\n    clearInterval(pingInterval);\n    pingInterval = null;\n  }\n  if (ws) {\n    ws.close();\n    ws = null;\n  }\n}\n\nexport function sendMessage(message) {\n  if (ws && ws.readyState === WebSocket.OPEN) {\n    ws.send(JSON.stringify(message));\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}