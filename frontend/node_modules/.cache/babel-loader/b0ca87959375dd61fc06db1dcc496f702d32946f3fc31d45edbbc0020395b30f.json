{"ast":null,"code":"let ws = null;\nlet reconnectAttempts = 0;\nconst maxReconnectAttempts = 5;\nconst reconnectDelay = 3000;\nexport function connectWebSocket(onMessage, onError, onClose) {\n  const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n  const host = window.location.hostname;\n  const port = process.env.REACT_APP_WS_PORT || '8000';\n  const wsUrl = `${protocol}//${host}:${port}/ws`;\n  try {\n    ws = new WebSocket(wsUrl);\n    ws.onopen = () => {\n      console.log('WebSocket connected');\n      reconnectAttempts = 0;\n      // Send ping to keep connection alive\n      setInterval(() => {\n        if (ws && ws.readyState === WebSocket.OPEN) {\n          ws.send('ping');\n        }\n      }, 30000);\n    };\n    ws.onmessage = event => {\n      try {\n        const data = JSON.parse(event.data);\n        if (onMessage) {\n          // Handle different message types\n          if (data.type === 'workload_update') {\n            onMessage(data.data);\n          } else if (data.type === 'notification') {\n            // Handle notification separately if needed\n            onMessage(data);\n          } else {\n            // Legacy format (direct workload data)\n            onMessage(data);\n          }\n        }\n      } catch (error) {\n        console.error('Error parsing WebSocket message:', error);\n      }\n    };\n    ws.onerror = error => {\n      console.error('WebSocket error:', error);\n      if (onError) {\n        onError(error);\n      }\n    };\n    ws.onclose = () => {\n      console.log('WebSocket disconnected');\n      if (onClose) {\n        onClose();\n      }\n\n      // Attempt to reconnect\n      if (reconnectAttempts < maxReconnectAttempts) {\n        reconnectAttempts++;\n        console.log(`Attempting to reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`);\n        setTimeout(() => {\n          connectWebSocket(onMessage, onError, onClose);\n        }, reconnectDelay);\n      } else {\n        console.error('Max reconnection attempts reached');\n      }\n    };\n  } catch (error) {\n    console.error('Failed to create WebSocket:', error);\n    if (onError) {\n      onError(error);\n    }\n  }\n}\nexport function disconnectWebSocket() {\n  if (ws) {\n    ws.close();\n    ws = null;\n  }\n}\nexport function sendMessage(message) {\n  if (ws && ws.readyState === WebSocket.OPEN) {\n    ws.send(JSON.stringify(message));\n  }\n}","map":{"version":3,"names":["ws","reconnectAttempts","maxReconnectAttempts","reconnectDelay","connectWebSocket","onMessage","onError","onClose","protocol","window","location","host","hostname","port","process","env","REACT_APP_WS_PORT","wsUrl","WebSocket","onopen","console","log","setInterval","readyState","OPEN","send","onmessage","event","data","JSON","parse","type","error","onerror","onclose","setTimeout","disconnectWebSocket","close","sendMessage","message","stringify"],"sources":["C:/sanfinal/frontend/src/services/websocket.js"],"sourcesContent":["let ws = null;\r\nlet reconnectAttempts = 0;\r\nconst maxReconnectAttempts = 5;\r\nconst reconnectDelay = 3000;\r\n\r\nexport function connectWebSocket(onMessage, onError, onClose) {\r\n  const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\r\n  const host = window.location.hostname;\r\n  const port = process.env.REACT_APP_WS_PORT || '8000';\r\n  const wsUrl = `${protocol}//${host}:${port}/ws`;\r\n\r\n  try {\r\n    ws = new WebSocket(wsUrl);\r\n\r\n    ws.onopen = () => {\r\n      console.log('WebSocket connected');\r\n      reconnectAttempts = 0;\r\n      // Send ping to keep connection alive\r\n      setInterval(() => {\r\n        if (ws && ws.readyState === WebSocket.OPEN) {\r\n          ws.send('ping');\r\n        }\r\n      }, 30000);\r\n    };\r\n\r\n    ws.onmessage = (event) => {\r\n      try {\r\n        const data = JSON.parse(event.data);\r\n        if (onMessage) {\r\n          // Handle different message types\r\n          if (data.type === 'workload_update') {\r\n            onMessage(data.data);\r\n          } else if (data.type === 'notification') {\r\n            // Handle notification separately if needed\r\n            onMessage(data);\r\n          } else {\r\n            // Legacy format (direct workload data)\r\n            onMessage(data);\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error('Error parsing WebSocket message:', error);\r\n      }\r\n    };\r\n\r\n    ws.onerror = (error) => {\r\n      console.error('WebSocket error:', error);\r\n      if (onError) {\r\n        onError(error);\r\n      }\r\n    };\r\n\r\n    ws.onclose = () => {\r\n      console.log('WebSocket disconnected');\r\n      if (onClose) {\r\n        onClose();\r\n      }\r\n      \r\n      // Attempt to reconnect\r\n      if (reconnectAttempts < maxReconnectAttempts) {\r\n        reconnectAttempts++;\r\n        console.log(`Attempting to reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`);\r\n        setTimeout(() => {\r\n          connectWebSocket(onMessage, onError, onClose);\r\n        }, reconnectDelay);\r\n      } else {\r\n        console.error('Max reconnection attempts reached');\r\n      }\r\n    };\r\n  } catch (error) {\r\n    console.error('Failed to create WebSocket:', error);\r\n    if (onError) {\r\n      onError(error);\r\n    }\r\n  }\r\n}\r\n\r\nexport function disconnectWebSocket() {\r\n  if (ws) {\r\n    ws.close();\r\n    ws = null;\r\n  }\r\n}\r\n\r\nexport function sendMessage(message) {\r\n  if (ws && ws.readyState === WebSocket.OPEN) {\r\n    ws.send(JSON.stringify(message));\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}